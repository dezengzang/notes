# LUTNet 阅读笔记

## LUTNet是什么
总体而言LUTNet是使用查找表(LUT)来替换乘法，我们姑且将这种运算方法称为LUT算子。下面我们通过一个例子阐述普通的全连接层和使用LUT算子的全连接层之间的联系。

如***图1***所示，以输入尺寸为Nx1的全连接层为例，为得到一个FC输出特征点Oi，需要对N个特征像素乘以对应的权重，并求和。

![](./images/mul_fc.png)

当使用LUT算子时，就是将每个输入特征对应的“乘权重”操作转化为查找表操作。LUT算子的FC原理如***图2***。N个输入特征像素，对应N个K输入查找表(K-LUT)，对于第n个K-LUT而言，查找表的第1个输入为对应的第n个输入特征点，其余K-1个输入从输入特征图的其余N-1个点中随机选取。之后将N个查找表的值求和，结合输入特征的2个位，即可得到1个输出的特征点。类似进行M次，即可得到M个输出特征点。

![](./images/lut_fc.png)

## LUTNet的实现

### 训练

- 使用拉格朗日插值模拟LUT，如下式，使用2^K个系数可以模拟一个K-LUT，用g^来近似查找表进行训练(**详细的LUT表达过程可以参看同目录下的“拉格朗日.docx”**)。
![](./images/interpolating.png)

- 训练过程
    1. 训练RebNet
    2. 剪枝RebNet（3值，提高表达能力，对权重进行剪枝）
    3. 再训练RebNet
    4. 将RebNet的权重映射位LUTNet的权重，二值化，再训练

### 权重转化为LUT

一个特征点与权重相乘可以转化为一个K-LUT，我们来看一下，经过上面几步训练好的拉格朗日系数如何转化为K-LUT，一个LUT需要用2^K个参数进行模拟，论文中论证K=4即可取得较好效果，因此K选为4。我们对第2个卷积核的第110个4-LUT分析，权重转化LUT的代码如下。LUT的第一个输入为in_V[110]，其余的in_?_V[110]都是从in_V[110]洗牌得到的随机特征点。等式右侧第1列的1和0的序列即为二值化后的拉格朗日系数，后面的就是4种输入的2^4种组合。这么一长串代码即对应着一个4-LUT，根据这段代码Vivado可以综合成4-LUT。

```verilog
assign tmp_2_110 = (1 & in_V[110] & in_1_V[110] & in_2_V[110] & in_3_V[110]) | 
                   (1 & in_V[110] & in_1_V[110] & in_2_V[110] & ~in_3_V[110]) | 
                   (1 & in_V[110] & in_1_V[110] & ~in_2_V[110] & in_3_V[110]) | 
                   (1 & in_V[110] & in_1_V[110] & ~in_2_V[110] & ~in_3_V[110]) | 
                   (1 & in_V[110] & ~in_1_V[110] & in_2_V[110] & in_3_V[110]) | 
                   (1 & in_V[110] & ~in_1_V[110] & in_2_V[110] & ~in_3_V[110]) | 
                   (1 & in_V[110] & ~in_1_V[110] & ~in_2_V[110] & in_3_V[110]) | 
                   (1 & in_V[110] & ~in_1_V[110] & ~in_2_V[110] & ~in_3_V[110]) | 
                   (0 & ~in_V[110] & in_1_V[110] & in_2_V[110] & in_3_V[110]) | 
                   (0 & ~in_V[110] & in_1_V[110] & in_2_V[110] & ~in_3_V[110]) | 
                   (1 & ~in_V[110] & in_1_V[110] & ~in_2_V[110] & in_3_V[110]) | 
                   (1 & ~in_V[110] & in_1_V[110] & ~in_2_V[110] & ~in_3_V[110]) | 
                   (0 & ~in_V[110] & ~in_1_V[110] & in_2_V[110] & in_3_V[110]) | 
                   (0 & ~in_V[110] & ~in_1_V[110] & in_2_V[110] & ~in_3_V[110]) | 
                   (0 & ~in_V[110] & ~in_1_V[110] & ~in_2_V[110] & in_3_V[110]) | 
                   (1 & ~in_V[110] & ~in_1_V[110] & ~in_2_V[110] & ~in_3_V[110]);
```

Vivado生成的查找表
![](./images/a_lut.png)

Vivado生成的对应真值表

![](./images/truth_table.png)

## LUTNet网络结构

表1是原文中对网络结构的介绍，表中标红的层使用了LUT算子展开。可以看出，LUT算子一般用在全连接层或者紧邻全连接层的卷积层。
![](./images/net_arch.png)
